# Список вопросов и ответов для собеседования на позицию Python-разработчик (Middle) [(на базу)](база.md)

### 1. Основы Python

#### Q1: Что такое GIL (Global Interpreter Lock) в Python?
GIL — это механизм в CPython, который позволяет только одному потоку выполнять Python-байткод одновременно. Это означает, что многопоточные программы на Python не могут использовать несколько ядер процессора для выполнения Python-кода. Однако GIL не влияет на многопроцессорность или асинхронные операции.

---

#### Q2: Как работает сборщик мусора в Python?
Сборщик мусора в Python использует три механизма:
1. **Счетчик ссылок:** Отслеживает количество ссылок на объект. Если счетчик достигает нуля, объект удаляется.
2. **Generational Garbage Collection:** Ищет циклические ссылки (например, два объекта ссылаются друг на друга).
3. **Weak References:** Позволяет создавать ссылки, которые не увеличивают счетчик ссылок.

---

#### Q3: Разница между `__str__` и `__repr__`?
- `__str__`: Предназначен для удобочитаемого представления объекта (для пользователей).
- `__repr__`: Предназначен для однозначного представления объекта (для разработчиков). Должен быть валидным *Python*-выражением.

Пример:
```Python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __str__(self):
        return f"Point({self.x}, {self.y})"

    def __repr__(self):
        return f"Point(x={self.x}, y={self.y})"

p = Point(1, 2)
print(str(p))  # Point(1, 2)
print(repr(p))  # Point(x=1, y=2)
```
---

#### Q4: Что такое метаклассы в Python?
Метаклассы — это "классы классов". Они позволяют контролировать создание и поведение классов. Например, метаклассы могут использоваться для автоматического добавления методов или проверки атрибутов.

Пример:
```Python
class Meta(type):
    def __new__(cls, name, bases, dct):
        dct["added_method"] = lambda self: "Added by metaclass"
        return super().__new__(cls, name, bases, dct)

class MyClass(metaclass=Meta):
    pass

obj = MyClass()
print(obj.added_method())  # Added by metaclass
```
---

### 2. Объектно-ориентированное программирование (ООП)

#### Q5: Что такое Mixin? Когда его использовать?
Mixin — это класс, предоставляющий определенные методы для повторного использования. Он не предназначен для самостоятельного использования, а используется для расширения функциональности других классов через множественное наследование.

Пример:
```Python
class JSONSerializableMixin:
    def to_json(self):
        import json
        return json.dumps(self.__dict__)

class User(JSONSerializableMixin):
    def __init__(self, name, age):
        self.name = name
        self.age = age

user = User("Alice", 30)
print(user.to_json())  # {"name": "Alice", "age": 30}
```
---

#### Q6: Что такое MRO (Method Resolution Order)?
MRO — это порядок, в котором Python ищет методы в классах при множественном наследовании. Он определяется алгоритмом C3 Linearization.

Пример:
```Python
class A:
    def foo(self):
        print("A")

class B(A):
    def foo(self):
        print("B")

class C(A):
    def foo(self):
        print("C")

class D(B, C):
    pass

d = D()
d.foo()  # B (потому что MRO: D -> B -> C -> A)

print(D.mro())  # [<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
```
---

### 3. Базы данных

#### Q7: Разница между SQL и NoSQL базами данных?
- **SQL:** Реляционные базы данных (например, PostgreSQL, MySQL). Хранят данные в таблицах. Поддерживают сложные запросы и транзакции.
- **NoSQL:** Нереляционные базы данных (например, MongoDB, Redis). Хранят данные в формате документов, ключ-значение или графов. Более гибкие, но менее строгие.

---

#### Q8: Что такое индексы в базах данных? Зачем они нужны?
Индексы — это структуры данных, которые ускоряют поиск данных в таблицах. Они создаются для столбцов, по которым часто выполняются запросы. Однако индексы замедляют операции записи (INSERT, UPDATE, DELETE).

---

#### Q9: Что такое транзакции? Какие свойства ACID?
Транзакция — это последовательность операций, которая выполняется как единое целое. Она должна удовлетворять свойствам ACID:
- **Atomicity (Атомарность):** Все операции либо выполняются полностью, либо не выполняются вообще.
- **Consistency (Согласованность):** Данные остаются в согласованном состоянии.
- **Isolation (Изолированность):** Транзакции не влияют друг на друга.
- **Durability (Долговечность):** После завершения транзакции изменения сохраняются даже при сбоях.

---

### 4. Веб-разработка

#### Q10: Разница между синхронным и асинхронным кодом?
- **Синхронный код:** Выполняется последовательно, одна операция за другой. Может блокировать выполнение программы.
- **Асинхронный код:** Позволяет выполнять задачи параллельно, не блокируя основной поток. Используется для обработки I/O-операций (например, HTTP-запросов).

Пример:
```Python
import asyncio

async def task():
    print("Start")
    await asyncio.sleep(1)
    print("End")

asyncio.run(task())
```

---

#### Q11: Что такое middleware в контексте веб-фреймворков?
Middleware — это функции, которые выполняются до или после обработки запроса. Они используются для логирования, аутентификации, обработки ошибок и других задач.

Пример в FastAPI:
```Python
@app.middleware("http")
async def log_requests(request, call_next):
    print(f"Incoming request: {request.method} {request.url}")
    response = await call_next(request)
    print(f"Response status code: {response.status_code}")
    return response
```

---

#### Q12: Как работает JWT (JSON Web Token)?
JWT — это стандарт для передачи данных в виде JSON. Он состоит из трех частей:
1. **Header:** Алгоритм шифрования (например, HMAC SHA256).
2. **Payload:** Данные (например, user_id, роль).
3. **Signature:** Подпись, созданная на основе Header и Payload.

JWT используется для аутентификации и передачи данных между клиентом и сервером.

---

### 5. Общие вопросы

#### Q13: Как вы решаете проблемы производительности в Python?

1. Профилирую код с помощью инструментов (например, cProfile, Py-Spy).
2. Оптимизирую алгоритмы и структуры данных.
3. Использую кэширование (например, Redis).
4. Переписываю критические части кода на C/C++ или использую Cython.
5. Применяю многопроцессорность или асинхронность.

---

#### Q14: Что такое CI/CD? Какие инструменты вы использовали?
CI/CD (Continuous Integration / Continuous Deployment) — это практика автоматизации сборки, тестирования и развертывания приложений. Инструменты:
- Jenkins
- GitHub Actions
- GitLab CI/CD
- CircleCI

---

#### Q15: Какие паттерны проектирования вы знаете?
1. Singleton: Гарантирует, что класс имеет только один экземпляр.
2. Factory: Создает объекты без указания конкретного класса.
3. Observer: Реализует подписку на события.
4. Decorator: Добавляет функциональность к объекту динамически.

---

#### Q16: Как вы работаете с большими проектами?
1. Разделяю код на модули и пакеты.
2. Использую принципы SOLID и DRY.
3. Пишу тесты (unit, integration, end-to-end).
4. Документирую код и API.
5. Использую системы контроля версий (Git), CI/CD и issue-tracking (Jira).

"""
Дополнительные вопросы и ответы для собеседования на позицию Python-разработчик (Middle):

### 1. Асинхронность и многопоточность

#### Q17: Разница между многопоточностью и асинхронностью?
- **Многопоточность:** Использует несколько потоков для выполнения задач параллельно. Однако из-за GIL в Python, многопоточность не всегда эффективна для CPU-bound задач.
- **Асинхронность:** Использует один поток, но задачи выполняются по очереди, не блокируя выполнение других задач при ожидании I/O-операций (например, HTTP-запросов).

Пример асинхронности:
```Python
import asyncio

async def task():
    print("Start")
    await asyncio.sleep(1)
    print("End")

asyncio.run(task())
```
---

#### Q18: Что такое event loop в Python?
Event loop — это центральный механизм асинхронного программирования. Он управляет выполнением асинхронных задач, переключаясь между ними при возникновении событий (например, завершения I/O-операции).

Пример:
```Python
import asyncio

async def main():
    print("Task started")
    await asyncio.sleep(1)
    print("Task finished")

loop = asyncio.get_event_loop()
loop.run_until_complete(main())
```
---

#### Q19: Как работает `asyncio.gather`?
`asyncio.gather` позволяет запускать несколько асинхронных задач параллельно и собирать их результаты.

Пример:
```Python
import asyncio

async def task1():
    await asyncio.sleep(1)
    return "Task 1"

async def task2():
    await asyncio.sleep(2)
    return "Task 2"

async def main():
    results = await asyncio.gather(task1(), task2())
    print(results)

asyncio.run(main())
# Output: ['Task 1', 'Task 2']
```
---

### 2. Тестирование

#### Q20: Какие типы тестов вы знаете?
1. **Unit-тесты:** Проверяют отдельные функции или методы.
2. **Integration-тесты:** Проверяют взаимодействие между компонентами.
3. **End-to-end тесты:** Проверяют работу приложения целиком.
4. **Smoke-тесты:** Проверяют базовую работоспособность.
5. **Load-тесты:** Проверяют производительность под нагрузкой.

---

#### Q21: Какие инструменты для тестирования вы использовали?
- **Pytest:** Популярная библиотека для написания тестов.
- **Unittest:** Встроенный модуль для тестирования.
- **Mock:** Для создания моков (подмены реальных объектов).
- **Selenium:** Для тестирования веб-интерфейсов.
- **Locust:** Для нагрузочного тестирования.

---

#### Q22: Что такое coverage в тестировании?
Coverage — это метрика, которая показывает, какой процент кода покрыт тестами. Инструменты вроде `pytest-cov` помогают измерять покрытие.

Пример:

`pytest --cov=my_module tests/`

---

### 3. Работа с API

#### Q23: Разница между REST и GraphQL?
- **REST:** Использует фиксированные эндпоинты для получения данных. Может быть избыточным (возвращает больше данных, чем нужно).
- **GraphQL:** Позволяет клиенту запрашивать только нужные данные через один эндпоинт.

---

#### Q24: Как обрабатывать ошибки в REST API?
Ошибки в REST API обычно возвращаются с HTTP-статусами и JSON-телом:
- 400: Неверный запрос.
- 401: Неавторизован.
- 403: Запрещено.
- 404: Ресурс не найден.
- 500: Внутренняя ошибка сервера.

Пример:
```Python
@app.exception_handler(HTTPException)
async def http_exception_handler(request, exc):
    return JSONResponse(
        status_code=exc.status_code,
        content={"message": f"Oops! {exc.detail}"},
    )
```
---

### 4. Дополнительные темы

#### Q25: Что такое контекстные менеджеры? Пример использования?
Контекстные менеджеры позволяют управлять ресурсами (например, файлами или соединениями) с помощью оператора `with`.

Пример:
```Python
class ManagedFile:
    def __init__(self, filename):
        self.filename = filename

    def __enter__(self):
        self.file = open(self.filename, 'r')
        return self.file

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.file:
            self.file.close()

with ManagedFile('file.txt') as f:
    print(f.read())
```
---

#### Q26: Что такое дескрипторы в Python?
Дескрипторы — это классы, реализующие методы `__get__`, `__set__`, `__delete__`. Они используются для управления доступом к атрибутам.

Пример:
```Python
class Descriptor:
    def __get__(self, instance, owner):
        return instance._value

    def __set__(self, instance, value):
        instance._value = value

class MyClass:
    attr = Descriptor()

obj = MyClass()
obj.attr = 42
print(obj.attr)  # 42
```
---

#### Q27: Как работает `functools.lru_cache`?
`lru_cache` — это декоратор, который кэширует результаты вызовов функций для определенных аргументов. Это полезно для оптимизации дорогостоящих вычислений.

Пример:
```Python
from functools import lru_cache

@lru_cache(maxsize=128)
def fib(n):
    if n < 2:
        return n
    return fib(n-1) + fib(n-2)

print(fib(10))  # Вычисляется один раз и кэшируется
```
---

#### Q28: Что такое протоколы в Python?
Протоколы — это способ определения интерфейсов для классов. Они появились в Python 3.8 благодаря модулю `typing`.

Пример:
```Python
from typing import Protocol

class Flyable(Protocol):
    def fly(self) -> None:
        ...

class Bird:
    def fly(self):
        print("Bird is flying")

def let_it_fly(flyable: Flyable):
    flyable.fly()

let_it_fly(Bird())
```
---

### 5. Проекты и командная работа

#### Q29: Как вы организуете работу в команде?
1. Использую Git для контроля версий.
2. Работаю с issue-tracking системами (например, Jira).
3. Участвую в code review.
4. Соблюдаю соглашения по коду (PEP 8).
5. Использую CI/CD для автоматизации сборки и тестирования.

---

#### Q30: Как вы решаете конфликты при слиянии веток в Git?
1. Выполняю `git pull` для получения последних изменений.
2. Если возникает конфликт, редактирую файлы вручную.
3. После разрешения конфликта коммитю изменения:
   git add <file>
   git commit -m "Resolved merge conflict"
4. Завершаю слияние: `git push`.
