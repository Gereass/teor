**Введение в базы данных** [(на базу)](база.md)

База данных - это коллекция организованных данных, которые хранятся в компьютере и могут быть легко доступны и манипулированы.

**Типы баз данных**

1. **Реляционные базы данных** (RDBMS): используют таблицы для хранения данных, каждая таблица имеет столбцы и строки. Примеры: MySQL, PostgreSQL, SQLite.
2. **Нереляционные базы данных** (NoSQL): не используют таблицы для хранения данных, вместо этого используют другие структуры данных, такие как документы, графы или ключ-значение. Примеры: MongoDB, Cassandra, Redis.

**MongoDB**

* **Документо-ориентированная база данных**: хранит данные в виде JSON-подобных документов.
* **Гибкая схема**: нет фиксированной схемы, каждый документ может иметь свои собственные поля и типы данных.
* **Масштабируемость**: легко масштабируется горизонтально, добавляя новые узлы в кластер.
* **Высокая производительность**: поддерживает высокую производительность чтения и записи данных.

**SQLite**

* **Реляционная база данных**: использует таблицы для хранения данных.
* **Самостоятельная база данных**: не требует отдельного сервера, база данных хранится в одном файле.
* **Легкая в использовании**: проста в использовании и настройке.
* **Низкие системные требования**: требует минимальных системных ресурсов.

**PostgreSQL**

* **Реляционная база данных**: использует таблицы для хранения данных.
* **Объектно-реляционная база данных**: поддерживает объектно-ориентированные концепции, такие как наследование и полиморфизм.
* **Высокая производительность**: поддерживает высокую производительность чтения и записи данных.
* **Безопасность**: имеет встроенные механизмы безопасности, такие как шифрование и аутентификация.

**Сравнение баз данных**

| База данных | Тип | Схема | Масштабируемость | Производительность |
| --- | --- | --- | --- | --- |
| MongoDB | NoSQL | Гибкая | Высокая | Высокая |
| SQLite | RDBMS | Фиксированная | Низкая | Средняя |
| PostgreSQL | RDBMS | Фиксированная | Высокая | Высокая |

**Методы оптимизации запросов**

1. **Использование индексов**: индексы позволяют ускорить поиск данных в таблице.
2. **Оптимизация запросов**: использование оптимальных запросов, таких как `SELECT` вместо `SELECT *`.
3. **Использование кэша**: кэш позволяет хранить часто используемые данные в памяти, что ускоряет доступ к ним.
4. **Оптимизация соединений**: использование оптимальных соединений, таких как `INNER JOIN` вместо `CROSS JOIN`.
5. **Использование оконных функций**: оконные функции позволяют выполнять агрегации и сортировки данных без использования подзапросов.

**Методы оптимизации запросов**

### Использование индексов

Индексы позволяют ускорить поиск данных в таблице, создавая специальную структуру данных, которая позволяет быстро находить необходимые данные. Индексы можно создавать на отдельных столбцах или на комбинации столбцов.

* **Преимущества индексов**:
    + Ускорение поиска данных
    + Снижение нагрузки на базу данных
    + Уменьшение количества ошибок
* **Недостатки индексов**:
    + Увеличение размера базы данных
    + Трудности в обслуживании индексов
    + Необходимость дополнительных ресурсов для создания и обслуживания индексов

### B-деревья

Это структура данных, которая широко используется в базах данных и файловых системах для эффективного хранения и поиска данных. Они особенно полезны для работы с большими объемами данных, которые не помещаются в оперативную память, так как минимизируют количество операций чтения/записи на диск.

### Оптимизация запросов

Использование оптимальных запросов, таких как:

* **SELECT вместо SELECT \***: избегайте выборки ненужных данных
* **WHERE вместо HAVING**: фильтруйте данные на этапе выборки
* **JOIN вместо подзапросов**: объединяйте данные из нескольких таблиц
* **UNION вместо OR**: объединяйте результаты нескольких запросов

* **Преимущества оптимизации запросов**:
    + Ускорение выполнения запросов
    + Снижение нагрузки на базу данных
    + Уменьшение количества ошибок
* **Недостатки оптимизации запросов**:
    + Увеличение сложности запросов
    + Трудности в отладке и поддержке запросов

### Использование кэша

Кэш позволяет хранить часто используемые данные в памяти, что ускоряет доступ к ним. Кэш можно использовать для хранения результатов запросов, чтобы избежать повторной выборки данных.

* **Преимущества кэша**:
    + Ускорение доступа к данным
    + Снижение нагрузки на базу данных
    + Уменьшение количества ошибок
* **Недостатки кэша**:
    + Увеличение размера памяти
    + Трудности в обслуживании кэша
    + Необходимость дополнительных ресурсов для создания и обслуживания кэша

### Оптимизация соединений

Использование оптимальных соединений, таких как:

* **INNER JOIN вместо CROSS JOIN**: избегайте выборки ненужных данных
* **LEFT JOIN вместо RIGHT JOIN**: избегайте дублирования данных
* **FULL OUTER JOIN вместо UNION**: объединяйте результаты нескольких запросов

* **Преимущества оптимизации соединений**:
    + Ускорение выполнения запросов
    + Снижение нагрузки на базу данных
    + Уменьшение количества ошибок
* **Недостатки оптимизации соединений**:
    + Увеличение сложности запросов
    + Трудности в отладке и поддержке запросов

### Использование оконных функций

Окна функции позволяют выполнять агрегации и сортировки данных без использования подзапросов. Окна функции можно использовать для:

* **Вычисления агрегатных значений**: сумма, среднее значение и т.д.
* **Сортировки данных**: по нескольким столбцам
* **Выбора данных**: из нескольких таблиц

* **Преимущества оконных функций**:
    + Ускорение выполнения запросов
    + Снижение нагрузки на базу данных
    + Уменьшение количества ошибок
* **Недостатки оконных функций**:
    + Увеличение сложности запросов
    + Трудности в отладке и поддержке запросов




**Примеры кода**
**SQL**
```SQL
# Выборка всех записей из таблицы:
SELECT * FROM customers;

# Выборка записей с определенным условием
SELECT * FROM customers WHERE country='USA';

# Сортировка записей
SELECT * FROM customers ORDER BY name ASC;

# Группировка записей
SELECT country, COUNT(*) AS count FROM customers GROUP BY country;

# Объединение таблиц
SELECT * FROM customers INNER JOIN orders ON customers.id = orders.customer_id;

# Подсчет суммы
SELECT SUM(total) AS total_sum FROM orders;

# Удаление записей
DELETE FROM customers WHERE id = 1;

# Обновление записей
UPDATE customers SET name = 'John Doe' WHERE id = 1;

# Создание таблицы
CREATE TABLE customers (
  id INT PRIMARY KEY,
  name VARCHAR(255),
  email VARCHAR(255)
);

# Индексирование столбца
CREATE INDEX idx_name ON customers (name);
```

**Python + db**
**MongoDB**
```python
import pymongo

# Создание соединения
client = pymongo.MongoClient("mongodb://localhost:27017/")

# Выбор базы данных
db = client["mydatabase"]

# Выбор коллекции
collection = db["mycollection"]

# Выполнение запроса
result = collection.find({"name": "John"})

# Обработка результатов
for document in result:
    print(document)
```
**SQLite**
```python
import sqlite3

# Создание соединения
conn = sqlite3.connect("mydatabase.db")

# Создание курсора
cursor = conn.cursor()

# Выполнение запроса
cursor.execute("SELECT * FROM mytable WHERE name = 'John'")

# Обработка результатов
rows = cursor.fetchall()
for row in rows:
    print(row)

# Закрытие соединения
conn.close()
```
**PostgreSQL**
```python
import psycopg2

# Создание соединения
conn = psycopg2.connect(
    host="localhost",
    database="mydatabase",
    user="myuser",
    password="mypassword"
)

# Создание курсора
cursor = conn.cursor()

# Выполнение запроса
cursor.execute("SELECT * FROM mytable WHERE name = 'John'")

# Обработка результатов
rows = cursor.fetchall()
for row in rows:
    print(row)

# Закрытие соединения
conn.close()```

