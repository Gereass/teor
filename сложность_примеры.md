### Сложность О [(на базу)](база.md)
### Пример 1: Функция, которая генерирует все возможные перестановки массива
``` python
def generate_permutations(arr):
    if len(arr) == 1:
        return [arr]
    permutations = []
    for i in range(len(arr)):
        element = arr[i]
        rest = arr[:i] + arr[i+1:]
        for p in generate_permutations(rest):
            permutations.append([element] + p)
    return permutations
```
#### Шаг 1: Определите функцию
- Функция `generate_permutations` генерирует все возможные перестановки массива.

#### Шаг 2: Определите входные данные
- Входными данными является массив `arr`.

#### Шаг 3: Определите выходные данные
- Выходными данными является список всех возможных перестановок массива.

#### Шаг 4: Анализируйте код
- Код функции содержит рекурсивный вызов, который генерирует все возможные перестановки массива.
- В каждом рекурсивном вызове функция генерирует все возможные перестановки массива, исключая один элемент.

#### Шаг 5: Определите количество операций
- Количество операций равно количеству элементов в массиве, умноженному на количество перестановок каждого элемента.
- Поскольку количество перестановок каждого элемента равно факториалу количества элементов, количество операций равно `n!`.

#### Шаг 6: Определите зависимость от входных данных
- Количество операций зависит от размера входного массива.
- Чем больше размер входного массива, тем больше количество операций.

#### Шаг 7: Оцените сложность
- Сложность функции равна `O(n!)`, поскольку количество операций пропорционально факториалу размера входного массива.

#### Шаг 8: Проверьте сложность
Мы можем проверить сложность функции, выполнив ее на разных входных данных и измерив время выполнения.
---
### Пример 2: Функция, которая находит все возможные подмножества множества
``` python
def generate_subsets(set_):
    if len(set_) == 0:
        return [[]]
    subsets = []
    for i in range(len(set_)):
        element = set_[i]
        rest = set_[:i] + set_[i+1:]
        for s in generate_subsets(rest):
            subsets.append(s)
            subsets.append([element] + s)
    return subsets
```
#### Шаг 1: Определите функцию
- Функция `generate_subsets` находит все возможные подмножества множества.

#### Шаг 2: Определите входные данные
- Входными данными является множество `set`.

#### Шаг 3: Определите выходные данные
- Выходными данными является список всех возможных подмножеств множества.

#### Шаг 4: Анализируйте код
- Код функции содержит рекурсивный вызов, который генерирует все возможные подмножества множества.
- В каждом рекурсивном вызове функция генерирует все возможные подмножества множества, исключая один элемент.

#### Шаг 5: Определите количество операций
- Количество операций равно количеству элементов в множестве, умноженному на количество подмножеств каждого элемента.
- Поскольку количество подмножеств каждого элемента равно 2, количество операций равно `2^n`.

#### Шаг 6: Определите зависимость от входных данных
- Количество операций зависит от размера входного множества.
- Чем больше размер входного множества, тем больше количество операций.

#### Шаг 7: Оцените сложность
- Сложность функции равна `O(2^n)`, поскольку количество операций пропорционально 2 в степени размера входного множества.

#### Шаг 8: Проверьте сложность
- Мы можем проверить сложность функции, выполнив ее на разных входных данных и измерив время выполнения.

---
### Пример 3: Функция, которая находит все возможные пути в графе
Графы - это математическая структура, которая представляет собой набор объектов (вершин) и связей между ними (ребер). Графы используются для моделирования различных систем и отношений в различных областях, таких как информатика, физика, биология, социология и другие.
```python
def find_paths(graph, start, end):
    if start == end:
        return [[start]]
    paths = []
    for neighbor in graph[start]:
        for path in find_paths(graph, neighbor, end):
            paths.append([start] + path)
    return paths
```
#### Шаг 1: Определите функцию
- Функция `find_paths` находит все возможные пути в графе от вершины `start` до вершины `end`.

#### Шаг 2: Определите входные данные
1. Входными данными являются:
    - `graph`: граф, представленный в виде словаря, где каждая вершина является ключом, а значение является списком соседних вершин.
    - `start`: вершина, с которой начинается поиск пути.
    - `end`: вершина, до которой нужно найти путь.

#### Шаг 3: Определите выходные данные
- Выходными данными является список всех возможных путей в графе от вершины `start` до вершины `end`.

#### Шаг 4: Анализируйте код
- Код функции содержит рекурсивный вызов, который находит все возможные пути в графе.
- В коде используется цикл, который проходит по соседним вершинам текущей вершины и рекурсивно вызывает функцию для каждой соседней вершины.

#### Шаг 5: Определите количество операций
- Количество операций равно `O(n!)`, где ***n*** - количество вершин в графе.
- Это потому, что для каждой вершины функция генерирует все возможные пути до вершины `end`, что может привести к экспоненциальному росту количества операций.

#### Шаг 6: Определите зависимость от входных данных
- Количество операций зависит от количества вершин в графе и от структуры графа.
- Если граф имеет много вершин и ребер, количество операций может быть очень большим.

#### Шаг 7: Оцените сложность
- Сложность функции равна `O(n!)`, что указывает на экспоненциальный рост количества операций с увеличением количества вершин в графе.

#### Шаг 8: Проверьте сложность
- Мы можем проверить сложность функции, выполнив ее на разных графах и измерив время выполнения.
- Для небольших графов функция должна работать быстро, но для больших графов функция может работать очень долго из-за экспоненциального роста количества операций.
---

### Пример 4: Функция, которая находит все возможные решения задачи о рюкзаке
У вас есть рюкзак с ограниченной вместимостью (например, 10 кг) и набор предметов с разными весами и стоимостями. Вам нужно выбрать подмножество предметов, чтобы поместить их в рюкзак, так чтобы общий вес не превышал вместимость рюкзака, а общая стоимость была максимальной. Вам нужно выбрать предметы, чтобы поместить их в рюкзак, так чтобы общий вес не превышал 10 кг, а общая стоимость была максимальной.

```python
def knapsack(capacity, weights, values):
    if capacity == 0 or len(weights) == 0:
        return 0
    if weights[0] > capacity:
        return knapsack(capacity, weights[1:], values[1:])
    return max(knapsack(capacity, weights[1:], values[1:]), values[0] + knapsack(capacity - weights[0], weights[1:], values[1:]))
```

#### Шаг 1: Определите функцию
- Функция `knapsack` находит все возможные решения задачи о рюкзаке, где нужно максимизировать стоимость предметов в рюкзаке с ограниченной вместимостью.

#### Шаг 2: Определите входные данные
1. Входными данными являются:
    - `capacity`: вместимость рюкзака.
    - `weights`: список весов предметов.
    - `values`: список стоимостей предметов.

#### Шаг 3: Определите выходные данные
- Выходными данными является максимальная стоимость предметов, которые можно поместить в рюкзак.

#### Шаг 4: Анализируйте код
- Код функции содержит рекурсивный вызов, который находит все возможные решения задачи о рюкзаке.
- В коде используется условный оператор, который проверяет, можно ли поместить текущий предмет в рюкзак, и если да, то рекурсивно вызывает функцию с уменьшенной вместимостью и без текущего предмета.

#### Шаг 5: Определите количество операций
- Количество операций равно `O(2^n)`, где ***n*** - количество предметов.
- Это потому, что для каждого предмета функция генерирует два возможных решения: одно с предметом, и одно без него.

#### Шаг 6: Определите зависимость от входных данных
- Количество операций зависит от количества предметов и от вместимости рюкзака.
- Если количество предметов велико, количество операций может быть очень большим.

#### Шаг 7: Оцените сложность
- Сложность функции равна `O(2^n)`, что указывает на экспоненциальный рост количества операций с увеличением количества предметов.

#### Шаг 8: Проверьте сложность
- Мы можем проверить сложность функции, выполнив ее на разных входных данных и измерив время выполнения.
- Для небольших входных данных функция должна работать быстро, но для больших входных данных функция может работать очень долго из-за экспоненциального роста количества операций.

---
### Пример 5: Функция, которая находит все возможные решения задачи о назначении
У вас есть набор задач (или работ) и набор работников (или ресурсов), которые могут выполнять эти задачи. Каждый работник имеет определенные навыки и способности, и каждая задача требует определенных навыков и ресурсов. Вам нужно назначить каждую задачу одному из работников, так чтобы каждая задача была выполнена ровно одним работником, и каждый работник выполнял ровно одну задачу.
```python
def assignment(costs):
    if len(costs) == 0:
        return 0
    min_cost = float('inf')
    for i in range(len(costs)):
        for j in range(len(costs[0])):
            if costs[i][j] < min_cost:
                min_cost = costs[i][j]
                min_index = (i, j)
    return min_cost + assignment([row[:j] + row[j+1:] for row in costs[:i] + costs[i+1:]])
```

#### Шаг 1: Определите функцию
- Функция `assignment` находит все возможные решения задачи о назначении, где нужно минимизировать стоимость назначения задач на работников.

#### Шаг 2: Определите входные данные
- Входными данными является матрица `costs`, где каждая ячейка представляет стоимость назначения задачи на работника.

#### Шаг 3: Определите выходные данные
- Выходными данными является минимальная стоимость назначения задач на работников.

#### Шаг 4: Анализируйте код
- Код функции содержит рекурсивный вызов, который находит все возможные решения задачи о назначении.
- В коде используется условный оператор, который проверяет, можно ли назначить задачу на работника, и если да, то рекурсивно вызывает функцию с уменьшенной матрицей и без текущей задачи.

#### Шаг 5: Определите количество операций
- Количество операций равно `O(n!)`, где ***n*** - количество задач.
- Это потому, что для каждой задачи функция генерирует все возможные решения: одно с задачей, и одно без нее.

#### Шаг 6: Определите зависимость от входных данных
- Количество операций зависит от количества задач и от размера матрицы.
- Если количество задач велико, количество операций может быть очень большим.

#### Шаг 7: Оцените сложность
- Сложность функции равна `O(n!)`, что указывает на экспоненциальный рост количества операций с увеличением количества задач.

#### Шаг 8: Проверьте сложность
- Мы можем проверить сложность функции, выполнив ее на разных входных данных и измерив время выполнения.
- Для небольших входных данных функция должна работать быстро, но для больших входных данных функция может работать очень долго из-за экспоненциального роста количества операций.
---

### Пример 6  сортировки массива методом слияния
```python
import time

def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

def merge(left, right):
    result = []
    while len(left) > 0 and len(right) > 0:
        if left[0] <= right[0]:
            result.append(left.pop(0))
        else:
            result.append(right.pop(0))
    result.extend(left)
    result.extend(right)
    return result

arr = [5, 2, 8, 3, 1, 6, 4, 7]
start_time = time.time()
merge_sort(arr)
end_time = time.time()
print("Время выполнения:", end_time - start_time)
```
#### Шаг 1: Определите функцию
- Функция `merge_sort` сортирует массив методом слияния.

#### Шаг 2: Определите входные данные
- Входными данными является массив `arr`, который нужно отсортировать.

#### Шаг 3: Определите выходные данные
- Выходными данными является отсортированный массив `arr`.

#### Шаг 4: Анализируйте код
- Код функции `merge_sort` делит массив на две части, сортирует каждую часть отдельно, и затем сливает две отсортированные части в одну отсортированную часть.
- Код функции `merge` сливает две отсортированные части в одну отсортированную часть.

#### Шаг 5: Определите количество операций
1. Количество операций в функции `merge_sort` равно:
    - 1 операция деления массива на две части (`O(1)`)
    - 2 операции сортировки каждой части отдельно (`O(n)`)
    - 1 операция слияния двух отсортированных частей (`O(n)`)
2. Количество операций в функции `merge` равно:
    - 1 операция сравнения двух элементов (`O(1)`)
    - 1 операция добавления элемента в результат (`O(1)`)
- Поскольку функция `merge_sort` вызывает функцию `merge` рекурсивно, количество операций в функции `merge_sort` равно:
    `O(n) + O(n) + O(n) = O(3n) = O(n)`

#### Шаг 6: Определите зависимость от входных данных
- Количество операций в функции `merge_sort` зависит от размера входного массива `arr`.
- Если размер массива увеличивается, количество операций также увеличивается.

#### Шаг 7: Оцените сложность
- Сложность функции `merge_sort` равна `O(n log n)`, потому что:
    - Количество операций деления массива на две части равно `O(log n)`
    - Количество операций сортировки каждой части отдельно равно `O(n)`
    - Количество операций слияния двух отсортированных частей равно `O(n)`
    - Поскольку функция `merge_sort` вызывает функцию `merge` рекурсивно, сложность функции `merge_sort` равна `O(n) * O(log n) = O(n log n)`

#### Шаг 8: Проверьте сложность
- Мы можем проверить сложность функции `merge_sort`, выполнив ее на разных входных данных и измерив время выполнения.
- Если сложность функции `merge_sort` равна `O(n log n)`, время выполнения должно увеличиваться логарифмически с увеличением размера входного массива.