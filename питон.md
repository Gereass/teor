# ПИТООООН [(на базу)](база.md)
### Основы:

`Python` - является императивным языком программирования. В императивном программировании программист составляет последовательность команд, которые выполняются компьютером.
***"Императивный язык"*** — это термин, который относится к классу языков программирования, использующих прямые команды для управления компьютером.

`Python` - это высокоуровневый язык программирования, который работает следующим образом:
1. **Синтаксический анализ**: *Python* читает код и анализирует его синтаксис.
2. **Компиляция**: *Python* компилирует код в байт-код. Помещает в файл `.pyc`, изменяется, если есть изменения в коде.
3. **Выполнение**: Байт-код выполняется виртуальной машиной `Python (PVM)`.
4. **Интерпретация**: `PVM` интерпретирует байт-код и выполняет соответствующие действия.
5. **Управление памятью**: *Python* автоматически управляет памятью, освобождая ее, когда она больше не нужна.

**Ключевые компоненты**
* **Интерпретатор**: Читает код и компилирует его в байт-код.
* **Виртуальная машина**: Выполняет байт-код и управляет памятью.
* **Библиотеки**: Предоставляют функции и классы для работы с различными задачами.

#### **Сборщик мусора**.
 Сборщик мусора в Python работает по принципу подсчета ссылок и циклического обнаружения. Когда количество ссылок на объект становится нулевым, он автоматически удаляется. Для обнаружения циклических ссылок используется алгоритм отслеживания циклов, чтобы освободить объекты, которые не могут быть удалены просто по подсчету ссылок.
---

### Типы данных и особенности:
* множества (`set set()`) - хранят только уникальные значения, принимают итерабельный объект. вынуть опредлелённый элемент только через преобразование, к примеру в лист, или циклом.
* списки (`list[]`) - делай что хочешь, мне всё равно.
* словари (`dict{}`) - храни как хочешь и что хочешь, но ключи должны быть уникальными. 
* кортежи (`tuple ()`) - храни что хочешь и сколько хочешь, но менять не смей! 
### Методы:
  Методы рабоыт часто совпадают, за исключением некоторых моментов, что бы не плоджить сущности напишу краткий список из нескольких методов, остальное, ищи сам.

- `keys()`: Возвращает список ключей в dict().
- `values()`: Возвращает список значений в dict().
- `items()`: Возвращает список пар ключ-значение в dict().
- `get()`: Возвращает значение по ключу, если ключ существует, иначе возвращает None.
- `setdefault()`: Устанавливает значение по ключу, если ключ не существует, иначе возвращает существующее значение.
- `update()`: Обновляет dict() новыми парами ключ-значение.
- `pop()`: Удаляет пару ключ-значение по ключу и возвращает значение.
- `popitem()`: Удаляет и возвращает первую пару ключ-значение в dict().
- `clear()`: Очищает dict().
- `max()`: Возвращает максимальный элемент.
- `min()`: Возвращает минимальный элемен.
- `copy()`: Возвращает копию словаря. 
---

### МААААГИЯ
  Магические методы в Python - это специальные методы, выделеные (`__`). Используются для переопределения поведения объектов и классов, и позволяют создавать более гибкие и удобные интерфейсы.
| 1 | 2 |
| --- | --- |
| `__init__`: Инициализирует объект при его создании. | `__len__`: Возвращает длину объекта. |
| `__str__`: Возвращает строковое представление объекта. | `__delattr__`: Удаляет атрибут объекта.|
| `__repr__`: Возвращает представление объекта, которое может быть использовано для его создания. | `__setattr__`: Устанавливает атрибут объекта.|
| `__eq__`: Сравнивает два объекта на равенство. | `__getattr__`: Возвращает атрибут объекта.|
| `__lt__`: Сравнивает два объекта на меньше. | `__call__`: Вызывает объект как функцию.|
| `__add__`: Складывает два объекта. | `__del__`: Удаляет объект.|
| `__new__`: Создает новый объект. |

#### Итераторы - это объекты, которые реализуют протокол итерации. Протокол итерации состоит из двух методов:
* `__iter__()`: Возвращает итератор для коллекции.
* `__next__()`: Возвращает следующий элемент коллекции.
---

### Пространство имён.

 В Python существуют три основных типа пространств имен: 
 - пространство имен модуля - все имена в модуле. Переменные, определенные в модуле, доступны только внутри этого модуля. 
 - пространство имен функции  - все "локальные" переменные, например в переменные функции. Видны только внутри функции.
 - встроенное пространство имен - все встроенные функции, классы и объекты Python (print, len, int и другие), доступны везде.
---

### Ассинхронность.
 Асинхронный код — это код, который позволяет выполнять операции без блокировки выполнения программы. Достигается за счет использования асинхронных функций и корутин. используется для операций с сетью и операций ввода вывода данных.

#### **event loop:**
`Event Loop` - это механизм, который позволяет программе обрабатывать события и выполнять задачи в асинхронном режиме.

##### Работа:
1. Создание событий: Программа создает события, которые необходимо обработать. События могут быть вызваны пользователем, сетевыми запросами, таймерами и другими источниками.
2. Добавление событий в очередь: События добавляются в очередь, где они ждут своей очереди на обработку.
3. Обработка событий: Event Loop обрабатывает события в очереди, выполняя соответствующие действия.
4. Повтор: Event Loop повторяет процесс обработки событий, пока не будут обработаны все события в очереди.

##### Пример 
```python
import asyncio
async def hello(): # <-- это кортурина
    await asyncio.sleep(1) # <-- это вызов кортурины
    print("Hello")

async def world():
    await asyncio.sleep(2)
    print("World")
    
async def main():
    await asyncio.gather(hello(), world())
    
if __name__ == '__main__': # <-- все асинхронные задачи будут работатьт, пока не завершится основная кортурина
    asyncio.run(main()) # <-- Запуск событийного цикла
```

### Многопоточность
#### **Гринлеты** 
##### Пример 
В этом примере создаются два гринлета, каждый из которых выполняет функцию task итеративно, выводя сообщения с задержкой в полсекунды между ними. Функция `gevent.joinall()` используется для ожидания завершения всех гринлетов перед завершением программы.

```PYTHON
import gevent

def task(name, num):
    for i in range(num):
        print(f'Task {name}: {i}')
        gevent.sleep(0.5)

gevent.joinall([
    gevent.spawn(task, 'A', 5),
    gevent.spawn(task, 'B', 5)
])
```

### ООООЧЕНЬ нужная штука **MRO** 
 `MRO (Method Resolution Order)` — это механизм в Python, который определяет порядок поиска методов и атрибутов в иерархии классов при наследовании.