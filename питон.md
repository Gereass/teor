# ПИТООООН [(на базу)](база.md)
### Основы:

`Python` - является императивным языком программирования. В императивном программировании программист составляет последовательность команд, которые выполняются компьютером.
***"Императивный язык"*** — это термин, который относится к классу языков программирования, использующих прямые команды для управления компьютером.

`Python` - это высокоуровневый язык программирования, который работает следующим образом:
1. **Синтаксический анализ**: *Python* читает код и анализирует его синтаксис.
2. **Компиляция**: *Python* компилирует код в байт-код. Помещает в файл `.pyc`, изменяется, если есть изменения в коде.
3. **Выполнение**: Байт-код выполняется виртуальной машиной `Python (PVM)`.
4. **Интерпретация**: `PVM` интерпретирует байт-код и выполняет соответствующие действия.
5. **Управление памятью**: *Python* автоматически управляет памятью, освобождая ее, когда она больше не нужна.

**Ключевые компоненты**
* **Интерпретатор**: Читает код и компилирует его в байт-код.
* **Виртуальная машина**: Выполняет байт-код и управляет памятью.
* **Библиотеки**: Предоставляют функции и классы для работы с различными задачами.

#### **Сборщик мусора**.
* Сборщик мусора в Python работает по принципу подсчета ссылок и циклического обнаружения. Когда количество ссылок на объект становится нулевым, он автоматически удаляется. Для обнаружения циклических ссылок используется алгоритм отслеживания циклов, чтобы освободить объекты, которые не могут быть удалены просто по подсчету ссылок.
---

### Типы данных и особенности:
* множества (`set set()`) - хранят только уникальные значения, принимают итерабельный объект. вынуть опредлелённый элемент только через преобразование, к примеру в лист, или циклом. Создаются через `a = {1,2,3}`
* списки (`list[]`) - делай что хочешь, мне всё равно.
* словари (`dict{}`) - храни как хочешь и что хочешь, но ключи должны быть уникальными. 
* кортежи (`tuple ()`) - храни что хочешь и сколько хочешь, но менять не смей! 
### Методы:
  Методы рабоыт часто совпадают, за исключением некоторых моментов, что бы не плоджить сущности напишу краткий список из нескольких методов, остальное, ищи сам.

- `keys()`: Возвращает список ключей в dict().
- `values()`: Возвращает список значений в dict().
- `items()`: Возвращает список пар ключ-значение в dict().
- `get()`: Возвращает значение по ключу, если ключ существует, иначе возвращает None.
- `setdefault()`: Устанавливает значение по ключу, если ключ не существует, иначе возвращает существующее значение.
- `update()`: Обновляет dict() новыми парами ключ-значение.
- `pop()`: Удаляет пару ключ-значение по ключу и возвращает значение.
- `popitem()`: Удаляет и возвращает первую пару ключ-значение в dict().
- `clear()`: Очищает dict().
- `max()`: Возвращает максимальный элемент.
- `min()`: Возвращает минимальный элемен.
- `copy()`: Возвращает копию словаря. 
---

### МААААГИЯ
  Магические методы в Python - это специальные методы, выделеные (`__`). Используются для переопределения поведения объектов и классов, и позволяют создавать более гибкие и удобные интерфейсы.
| 1 | 2 |
| --- | --- |
| `__init__`: Инициализирует объект при его создании. | `__len__`: Возвращает длину объекта. |
| `__str__`: Возвращает строковое представление объекта. | `__delattr__`: Удаляет атрибут объекта.|
| `__repr__`: Возвращает представление объекта, которое может быть использовано для его создания. | `__setattr__`: Устанавливает атрибут объекта.|
| `__eq__`: Сравнивает два объекта на равенство. | `__getattr__`: Возвращает атрибут объекта.|
| `__lt__`: Сравнивает два объекта на меньше. | `__call__`: Вызывает объект как функцию.|
| `__add__`: Складывает два объекта. | `__del__`: Удаляет объект.|
| `__new__`: Создает новый объект. |

#### Итераторы - это объекты, которые реализуют протокол итерации. Протокол итерации состоит из двух методов:
* `__iter__()`: Возвращает итератор для коллекции.
* `__next__()`: Возвращает следующий элемент коллекции.
---

### Пространство имён.

 В Python существуют три основных типа пространств имен: 
 - пространство имен модуля - все имена в модуле. Переменные, определенные в модуле, доступны только внутри этого модуля. 
 - пространство имен функции  - все "локальные" переменные, например в переменные функции. Видны только внутри функции.
 - встроенное пространство имен - все встроенные функции, классы и объекты Python (print, len, int и другие), доступны везде.
---

### Ассинхронность.
 Асинхронный код — это код, который позволяет выполнять операции без блокировки выполнения программы. Достигается за счет использования асинхронных функций и корутин. используется для операций с сетью и операций ввода вывода данных.

#### **event loop:**
`Event Loop` - это механизм, который позволяет программе обрабатывать события и выполнять задачи в асинхронном режиме.

##### Работа:
1. Создание событий: Программа создает события, которые необходимо обработать. События могут быть вызваны пользователем, сетевыми запросами, таймерами и другими источниками.
2. Добавление событий в очередь: События добавляются в очередь, где они ждут своей очереди на обработку.
3. Обработка событий: Event Loop обрабатывает события в очереди, выполняя соответствующие действия.
4. Повтор: Event Loop повторяет процесс обработки событий, пока не будут обработаны все события в очереди.

##### Пример 
```python
import asyncio
async def hello(): # <-- это кортурина
    await asyncio.sleep(1) # <-- это вызов кортурины
    print("Hello")

async def world():
    await asyncio.sleep(2)
    print("World")
    
async def main():
    await asyncio.gather(hello(), world())
    
if __name__ == '__main__': # <-- все асинхронные задачи будут работатьт, пока не завершится основная кортурина
    asyncio.run(main()) # <-- Запуск событийного цикла
```

### Многопоточность
#### **Гринлеты** 
##### Пример 
В этом примере создаются два гринлета, каждый из которых выполняет функцию task итеративно, выводя сообщения с задержкой в полсекунды между ними. Функция `gevent.joinall()` используется для ожидания завершения всех гринлетов перед завершением программы.

```PYTHON
import gevent

def task(name, num):
    for i in range(num):
        print(f'Task {name}: {i}')
        gevent.sleep(0.5)

gevent.joinall([
    gevent.spawn(task, 'A', 5),
    gevent.spawn(task, 'B', 5)
])
```
---
### ООООЧЕНЬ нужная штука **MRO** 
 `MRO (Method Resolution Order)` — это порядок, в котором *Python* ищет методы в классах при множественном наследовании. Этот порядок определяется алгоритмом **C3 Linearization**, который гарантирует, что методы будут вызываться в предсказуемом и согласованном порядке.

 Пример:
```python
class A:
    def method(self):
        print("A.method")

class B(A):
    def method(self):
        print("B.method")

class C(A):
    def method(self):
        print("C.method")

class D(B, C):
    pass

d = D()
d.method()

# Порядок поиска методов определяется MRO:
print(D.mro())
# [<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
# Итого будет выведено "B.method"
```

 Таким образом:

1. Метод сначала ищется в D.
2. Если его нет, ищется в B.
3. Если его нет, ищется в C.
4. Если его нет, ищется в A.

####  Алгоритм **C3 Linearization**

 Алгоритм **C3 Linearization** строит *MRO* следующим образом:

1. Класс сам помещается в начало списка.
2. Родительские классы добавляются в порядке их объявления.
3. Если два класса имеют общего предка, он добавляется только один раз и помещается в конец.
---
### Что такое `*args` и `**kwargs` в *Python*?

`*args` и `**kwargs` — это специальные синтаксические конструкции в *Python*, которые позволяют функциям принимать произвольное количество аргументов. Они особенно полезны, когда вы заранее не знаете, сколько аргументов будет передано в функцию.
1. `*args` собирает позиционные аргументы в *кортеж* ( ).
2. `**kwargs` собирает именованные аргументы в *словарь* { }.

 Пример:
```python
def process_data(*args, **kwargs):
    print("Positional arguments:", args)
    print("Keyword arguments:", kwargs)

process_data(1, 2, 3, name="Alice", age=30)

# Positional arguments: (1, 2, 3)
# Keyword arguments: {'name': 'Alice', 'age': 30}
```
---
## Интересные "штуки"
### Моржовый оператор
Оператор `:=` в *Python* называется оператором присваивания внутри выражений.

##### Основное назначение
Оператор `:=` полезен, когда нужно:

- Присвоить значение переменной.
- Использовать это значение в том же выражении, где происходит присваивание.
- Это особенно удобно для сокращения кода и улучшения читаемости в случаях, когда одно и то же значение

##### Примеры:

* Здесь **line** присваивается результат **input()** и сразу проверяется на пустую строку.
```Python
# Без
while True:
    line = input("Введите строку: ")
    if not line:
        break
    print(f"Вы ввели: {line}")
# С

while line := input("Введите строку: "):
    print(f"Вы ввели: {line}")

```

* Здесь **value** вычисляется один раз для каждого элемента списка и сразу используется в условии.
```Python
# Без
results = []
for item in items:
    value = expensive_computation(item)
    if value > 10:
        results.append(value)
# C    
results = [value for item in items if (value := expensive_computation(item)) > 10]
```
##### Недостатки:
1. Чрезмерное использование может ухудшить читаемость
2. Не стоит плодить говно там где можно обойтись простым `=` 

### Конструкция `->` 
* в *Python* — это способ явно указать тип возвращаемого значения функции. Она является частью системы аннотации типов и помогает сделать код более читаемым и поддерживаемым.
 
 Пример:
```python
def greet(name: str) -> str:
    return f"Hello, {name}"

print(greet("Alice"))  # Работает корректно
print(greet(123))      # Работает, но нарушает аннотацию
```